# 学习笔记-volatile关键字
## volatile关键字  
**volatile特性**  
&emsp;保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）(通过缓存一致，MESI协议，内存屏障实现)  
&emsp;禁止进行指令重排序。（实现有序性）

## 计算机主机组成  
&emsp;主要是CPU和内存。  
&emsp;一个程序的执行是主要牵扯到内存的存储和CPU的计算以及内存和CPU之间的通信(通过总线(数据总线、控制总线、地址总线)进行通信)。  
&emsp;CPU的运算速度大概是内存访问速度100倍。因为CPU的运算速度较快，所以在CPU和内存中有三级缓存 分别是L1cache L2cache L3cache。
## 缓存  
**CPU组成**  

&emsp;CPU的组成是Registers(寄存器)、ALU(计算单元)、PC寄存器、Cache(缓存)。在CPU中的 L1cache和L2cache是位于同一个核的，L3cache是位于同一颗CPU的。  
&emsp;超线程(如4核8线程) 指的就是 在一个核中一个计算单元，对应了两组寄存器。

**CPU获取数据**  

&emsp;当CPU需要一个数据时，会先去L1的缓存中查找，假如L1缓存中没有，就去L2缓存中查找，假如L2缓存中也没有，就会去L3缓存中去查找，假如L3缓存中也没有，才会去内存中查找数据。   

**CPU同步到缓存区**   

&emsp;当CPU从内存中拿到数据时，会先存到L3的缓存区，再存到L2缓存区，再存到L1缓存区。当CPU再次需要这个数据时，会再去L1缓存区中去找，找到后直接从L1缓存区将数据返回给CPU。 

**线程执行**  

&emsp;线程在CPU中的执行，就是指线程中的数据放到寄存器中，然后通过ALU(计算单元)来对他进行计算。

**线程切换**  

&emsp;线程切换就是指第一个线程在运行时，轮到第二个线程运行时，就会将第一个线程存到pc寄存器中去，然后再将第二个线程数据放到寄存器中，由计算单元执行。  

**缓存行**  
&emsp;缓存行(cache line):在数据从内存中读取到CPU中时，因为会有程序局部性原理(程序在运行中一般都是连续的读取数据) 为了提升效率，缓存在读取数据时就会按块读取，二非按位(bit)读取。缓存行的大小为64Bytes(64字节)。  
&emsp;在缓存行中：  
1.缓存行越大，局部性空间效率越高，但读取时间慢。  
2.缓存行越小，局部性空间效率越低，但读取时间快。  
所以目前的情况下缓存行失去一个折中值：64字节。  
&emsp;缓存一致性：就是当内存中的同一行的数据位于不同的缓存中时，如何保持数据一致性。(如何避免核1中拿到数据修改一部份，在修改后的数据还为返回到内存中时，核2中拿到同样的数据，修改一部分数据。当数据返回到内存中时，数据不一致情况)?  
&emsp;缓存时间利用了MESI Cache一致性协议(Intel的CPU协议):  
&emsp;&emsp;1.Modeified:被修改了  
&emsp;&emsp;2.EXclusive:独占  
&emsp;&emsp;3.Shared:共享读  
&emsp;&emsp;4.Invalid:无效  
当一个核中的计算单元修改缓存行之后，将缓存行状态修改为Modeified，并且通知其他核，将缓存行状态改为Invalid，将修改后的结果存入内存中，再让其他核再去内存中读取。  

**缓存行对齐**
&emsp;缓存行对齐：在内存中给值到CPU缓存时，往数据前加入7个long类型数据，后面加入7个long类型数据。使CPU中的多核减少缓存一致性的操作。jdk1.8后的注解@sun.misc.Contended:强制使数据不和其他数据位于同一行。说到底就是用空间来换时间。
&emsp;disruptor(世界上最快的单机版本的MQ)就是使用缓存行对齐的方式。

## 重排序
**CPU的乱序执行**  
&emsp;CPU在进行读等待的时候，同时执行了其他指令  

**重排序**  
&emsp;重排序就是CPU的内部优化。  
&emsp;as-if-serial:单线程的情况下，保证执行之后的结果一致，执行过程中的方法执行顺序发生改变并不会影响最终结果。看上去就像是序列化执行下来的。  

**禁止指令重排序**  
&emsp;当对一个方法或者是变量使用volatile时,就是禁止重排序。   
&emsp;hanppens-before原则(JVM规定重排序必须遵守的规则)（8条）  

**问题**  
一.解释对象的创建过程?  
&emsp;1.申请内存 赋默认值。  
&emsp;2.调用构造方法，把成员变量做成初始值。  
&emsp;3.建立关联，返回对象地址给引用。  
二.DCL单例需不需要加volatile?  
&emsp;DCL:Double check lock 双重检查锁 check-锁-check(单例模式中的)  
&emsp;必须要加volitile，在对象创建过程中 假如第一个线程开始 创建对象，但是当它申请完内存，并且赋好默认值之后，发生了指令重排序。假使正好线程2又要通过dcl的方式来创建对象，就会发现对象已经创建好了，就会直接使用。但是这个对象其实是还没有调用构造方法，初始化成员变量。就会造线程2会使用半初始化状态的对象。

## 内存屏障

**内存屏障**  
&emsp;内存屏障：防止指令重排序就是在两条指令之间加屏障。  
**jvm级别的四种内存屏障**  
&emsp;jvm级别的四种屏障：  
&emsp;1.LoadLoad屏障：Load1-LoadLoad-Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。  
&emsp;2.StoreStore屏障：Store1-StoreStore-Store2,在Store2及后续写入操作执行前，保证Store1的写入操作对其他处理器可见。  
&emsp;3.LoadStore屏障：在Store2及后续写入操作执行之前，保证Load1要读取的数据已经读取完毕。  
&emsp;4.StoreLoad屏障：在Load2及后续读取操作要读取数据被访问前，保证Store1的写入操作对其他处理器可见。  
**JVM层面volatile实现细节** 

*读操作*  

&emsp;----StoreStoreBarrier----   
&emsp;&emsp;&emsp;&emsp;volatile读  
&emsp;----StoreLoadBarrier----  

*写操作*  

&emsp;&emsp;&emsp;&emsp;volatile写  
&emsp;----LoadLoadBarrier----  
-&emsp;---LoadStoreBarrier----  

**X86 CPU的内存屏障**  
&emsp;1.sfence 在sfence指令前的写操作 必须在 sfence指令后的写操作前完成。  
&emsp;2.lfence  在lfence指令前的读操作 必须在 lfence指令后的读操作前完成。  
&emsp;3.mfence 在mfence指令前的读写操作 必须在 mfence指令后的读写操作前完成。  

**Lock指令**  
&emsp;操作系统层面的Lock指令：Lock用于在多处理器中执行指令时对共享内存的独占使用。它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。另外还提供了有序的指令 无法越过这个内存屏障的作用





