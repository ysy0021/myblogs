# 学习笔记-synchronized关键字

> &emsp;最近都在看网课学习，打算学习之后记录整理好学习笔记，以防之后忘掉。这是第一篇关于synchronized关键字的学习

## 用户态和内核态
- **cpu级别**  
    
    &emsp;在inter x86架构的cpu下一共有四个级别 从0到3 (ring 0-1-2-3) ring 0级别是最高的级别
    ring 3级别是最低的级别
- **用户态**  
  
    &emsp;用户态主要是用户的程序创建的进程，在开始时运行自己的代码时，是处于用户态。
- **内核态**  

    &emsp;内核态主要是在操作系统的内核中运行，直接访问硬件，负责分配内存、线程调度、锁申请、特权级别的程序
- **用户态和内核态概念**  
  
    &emsp;用户在运行一个程序时,该程序将创建出进程来运行自己的代码，这是处于用户态的。当这个程序需要执行文件操作、网络数据发送等需要系统调用的操作，进程就会切换成到ring0，然后在内核的地址中执行内核代码来完成相应的操作。内核态的进程完成之后又会切换回用户态ring3。这样的话，在用户态中是不能随意的操作内核的地址，保证了一定的安全性。

## CAS轻量级锁
- **轻量级锁**  
  
    &emsp;轻量级锁就是所有的操作都在用户态完成，不需要惊动内核态。
- **CAS**  
  
    &emsp;CAS也就是自旋锁，也有人称之为无锁、乐观锁。自旋锁简单来说就是一个比较并且修改的过程。线程取出内存中的值来进行了修改，修改之后再返回到内存中去比对，看这个值在内存中是否有线程修改了，如果有线程修改了这个值则将修改后的值返回到线程中，继续运行，直到有线程再更改这个值。  
    &emsp;&emsp;eg：定义多个i++的线程方法 然后在 第一个线程+1的时候 去内存中比对是否 为0 若不为0
	返回不为0的值到第一个线程 再+1 再去比对是否有其他线程更改过这个值 若有则 继续返回 更改后的值 再+1
	直到没有线程再更改内存中的值 才将第一个线程中的结果给到内存中。  
    &emsp;完成CAS必须要保证原子性。原因：取出内存中的值修改完成后。再去比对是否改变，比对完成之后再确定是修改还是返回继续运行。这个过程中在内存中比对值和修改值是两个步骤，所以需要保证原子性
- **ABA问题及解决方案**  

    &emsp;假设内存空间中存的值为0，当一个线程在你执行的+1的线程还未执行完成时，把你的内存中的值修改成8，另外又来一个线程将内存中的值从8有修改为0。这就是一个典型的ABA问题。  
    &emsp;解决方案：给原子类加上唯一标识，看是否有线程修改过它。

- **JDK中的原子性加锁**  
    &emsp;在java中jdk自带了AtomicXXXX的类用来实现原子性的加锁。Java中的方法 AtomicXXXXX 底层就是利用CAS实现，而CAS的底层就是 由汇编中的 lock compxchg 实现，其中lock是用来保障原子性。  
    &emsp;lock对于java来说算轻量级锁 对于cpu来说算重量级锁
    &emsp;无论是用户态的CAS还是重量级锁,最终都会进入到汇编的lock。看是否属于用户态还是内核态，主要是看是否经过操作系统的线程管理。

## synchronized重量级锁  
&emsp;在jdk1.1时期,synchronized主要是jvm通过os(用户态)去请求内核态来申请锁，内核态在在加锁完成之后，再将锁返回给用户态。  
&emsp;现在的synchronized操作主要在用户态，只有当用户态无法处理的时候才会去内核态申请。

## 偏向锁  
- **对象布局**  
&emsp;java中new一个object对象在堆中的布局，主要是由4项构成:  
&emsp;1.markword(主要记录了锁信息、hashcode信息、GC信息)  
&emsp;2.KP(指针，指向class的位置，object.class)  
&emsp;3.成员变量   
&emsp;4.padding 对齐(对于不能被8整除的字节大小 加到能被8整除))  
&emsp;假如是数组对象的话，会有5个，多一个长度。
- **偏向锁**  
&emsp;偏向锁的意思是偏向于第一个持有这个锁的线程，主要利用线程id来确定是哪个线程持有(即修改对象的markword)  
&emsp;偏向锁以及轻量级锁都是在用户态完成的。  
&emsp;重量级锁需要向操作系统申请空间 即内核态解决问题   
- **区分锁状态**  

![avatar](/image/markword.jpg)  
&emsp;在markword中主要是利用锁的标志位来区分的（markword最后两位 最后2bit）  
&emsp;00: 轻量级锁  
&emsp;10：重量级锁  
&emsp;11：gc信息 将要被回收  
&emsp;01：无锁状态或者是偏向锁 看倒数第三位 如果是0则是无锁状态 如果是1则是偏向锁状态  
## 锁升级  
![avatar](/image/锁升级.jpg)  
- 第一种  
&emsp;在new出对象后，偏向锁未开启，就会new出普通对象处于无锁状态。当有多个线程在开始轻度的竞争这个对象的时候，偏向锁就会升级成为轻量级锁，通过自旋来进行线程管理。在轻量级锁的过程中仍发现有很多线程在竞争，这样的话就会升级成为重量级锁，通过队列的方式来进行线程排序。
- 第二种  
&emsp;在new出对象之后，偏向锁未启动，再转为偏向锁，偏向锁轻度竞争之后变成轻量级锁，重度竞争之后变成重量级锁。普通对象->偏向锁(这部分之后再说)  
- 第三种  
&emsp;在偏向锁启动的时候，首先new出来的对象都是匿名偏向(没有任何线程进入)，之后转为偏向锁。偏向锁轻度竞争之后变成轻量级锁，重度竞争之后变成重量级锁。   
- **锁升级具体过程**   
&emsp;偏向锁升级轻量级锁：所有线程都是通过CAS的方式来进行竞争 看谁的线程id通过自旋的方式得到了这个锁。  
&emsp;轻量级锁升级重量级锁：自旋之后，发现线程处理时间长、线程多、等待时间长，会造成对于cpu的压力。重量级锁处理过程，以队列的方式来对线程进行排队。排队之后，以队列顺序的方式进行线程处理,就是公平锁；以竞争的方式进行线程处理,就是非公平锁。  
&emsp;偏向锁的启动有延迟。大概是4s 所以一般new 了对象之后就会到轻量级锁 
- **问题**  
&emsp;1.偏向锁为什么要延迟4s？打开偏向锁效率一定会提升么？为什么？  
&emsp;不一定会提升，尤其在明确知道了有多个线程会要竞争的情况下。延迟4s是因为jvm在启动的过程中 一定会产生锁竞争。因为需要创建对象、写入内存。JVM调优中就有设置偏向锁的启动。  
&emsp;2.轻量级锁在什么情况下会升级成重量级锁？  
&emsp;jdk1.6之前是当一个线程自旋了十次还未成功、等待的线程超过cpu核数的1/2 ，就会升级成重量级锁，jvm调优时可以调整这两个参数。
&emsp;jdk1.6之后 默认启动自适应自旋：自己计算有多少个线程在等待时升级、线程自旋多少次升级，由jvm自己控制。





