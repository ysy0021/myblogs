# 学习笔记-synchronized关键字

> &emsp;最近都在看网课学习，打算学习之后记录整理好学习笔记，以防之后忘掉。这是第一篇关于synchronized关键字的学习

## 用户态和内核态
- **cpu级别**  
    
    &emsp;在inter x86架构的cpu下一共有四个级别 从0到3 (ring 0-1-2-3) ring 0级别是最高的级别
    ring 3级别是最低的级别
- **用户态**  
  
    &emsp;用户态主要是用户的程序创建的进程，在开始时运行自己的代码时，是处于用户态。
- **内核态**  

    &emsp;内核态主要是在操作系统的内核中运行，直接访问硬件，负责分配内存、线程调度、锁申请、特权级别的程序
- **用户态和内核态概念**  
  
    &emsp;用户在运行一个程序时,该程序将创建出进程来运行自己的代码，这是处于用户态的。当这个程序需要执行文件操作、网络数据发送等需要系统调用的操作，进程就会切换成到ring0，然后在内核的地址中执行内核代码来完成相应的操作。内核态的进程完成之后又会切换回用户态ring3。这样的话，在用户态中是不能随意的操作内核的地址，保证了一定的安全性。

## CAS轻量级锁
- **轻量级锁**  
  
    &emsp;轻量级锁就是所有的操作都在用户态完成，不需要惊动内核态。
- **CAS**  
  
    &emsp;CAS也就是自旋锁，也有人称之为无锁、乐观锁。自旋锁简单来说就是一个比较并且修改的过程。线程取出内存中的值来进行了修改，修改之后再返回到内存中去比对，看这个值在内存中是否有线程修改了，如果有线程修改了这个值则将修改后的值返回到线程中，继续运行，直到有线程再更改这个值。  
    &emsp;&emsp;eg：定义多个i++的线程方法 然后在 第一个线程+1的时候 去内存中比对是否 为0 若不为0
	返回不为0的值到第一个线程 再+1 再去比对是否有其他线程更改过这个值 若有则 继续返回 更改后的值 再+1
	直到没有线程再更改内存中的值 才将第一个线程中的结果给到内存中。  
    &emsp;完成CAS必须要保证原子性。原因：取出内存中的值修改完成后。再去比对是否改变，比对完成之后再确定是修改还是返回继续运行。这个过程中在内存中比对值和修改值是两个步骤，所以需要保证原子性
- **ABA问题及解决方案**  

    &emsp;假设内存空间中存的值为0，当一个线程在你执行的+1的线程还未执行完成时，把你的内存中的值修改成8，另外又来一个线程将内存中的值从8有修改为0。这就是一个典型的ABA问题。  
    &emsp;解决方案：给原子类加上唯一标识，看是否有线程修改过它。

- **JDK中的原子性加锁**  
    &emsp;在java中jdk自带了AtomicXXXX的类用来实现原子性的加锁。Java中的方法 AtomicXXXXX 底层就是利用CAS实现，而CAS的底层就是 由汇编中的 lock compxchg 实现，其中lock是用来保障原子性。  
    &emsp;lock对于java来说算轻量级锁 对于cpu来说算重量级锁
    &emsp;无论是用户态的CAS还是重量级锁,最终都会进入到汇编的lock。看是否属于用户态还是内核态，主要是看是否经过操作系统的线程管理。
